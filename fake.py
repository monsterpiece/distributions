#!/usr/bin/python
# -*- coding:utf-8 -*-
from __future__ import division
import random
import numpy as np

class Transaction(object):
    """Transaction class

    """
    def __init__(self,_from,_to,amount,timestamp):
        self._from = _from
        self._to = _to
        self.amount = amount
        self.timestamp = timestamp
    
    def toString(self):
        return ','.join([self._from,self._to,str(self.timestamp),("%.6f" % self.amount)])

def generateNoise(transactions,addressList,timestamps,delNumber,addNumber):
    """Generate noisy transactions
    We will add or remove edges randomly from exisiting graph.
    
    transactions: the list of transactions

    addressList: the list of all addresses recorded in above transaction

    timestamps:interval of valid timestamp, like [104001,104010]

    delNumber: the amount of transactions which are randomly deleted

    addNumber: the amount of transactions which are randomly generated
    """
    if delNumber<0:
        delNumber = 0
    elif delNumber > len(transactions):
        delNumber = len(transactions)
    
    if addNumber<0:
        addNumber = 0


    #delete some transactions
    delList = random.sample(range(len(transactions)),delNumber)
    delList = sorted(delList)
    for i in range(len(delList)-1,-1,-1):
        transactions.pop(delList[i])
    
    #add some transactions
    for i in xrange(addNumber):
        from_index = random.randint(0,len(address)-1)
        to_index = random.randint(0,len(address)-1)
        iter = 0
        while iter < 10 and to_index == from_index:
            to_index = random.randint(0,len(address)-1)
        if to_index == from_index:
            to_index = from_index + 1
            if to_index >= len(address):
                to_index = from_index -1
        _from = addressList[from_index]
        _to= addressList[to_index]
        
        _timestamp = random.randint(timestamps[0],timestamps[1])
        _amount = random.random()
        transactions.append(Transaction(_from,_to,_amount,_timestamp))

    return sorted(transactions, key =(lambda x: x.timestamp))

def generateFake(transactions,cheatingAddress,supportAddressList,fakeAddressList,totalAmount,timestamps,method='uniform'):
    """Generate fake transactions
    We will add new fake address and fake transaction to original transation list.
    
    transactions: original transaction list

    cheatingAddress: the address that is willing to do bad behaviors

    supportAddressList: a list of pretty important addresses
    
    fakeAddressList: fake addresses generated by cheating user.

    totalAmount:the amount of cheatingAddress transferring out.

    method: the way cheatingAddress giving its money out
        - 'uniform':transfer to every fake address equally
        - 'random':transfer to every fake address randomly
    
    """
    if method == 'uniform':
        count = max(1,len(fakeAddressList))
        amounts = [totalAmount / count] * count
    else:
        lis = sorted(list(np.random.uniform(0.000001,totalAmount-0.000001,len(fakeAddressList)-1)))
        lis.append(totalAmount)
        amounts = [] 
        last = 0
        for index,amount in enumerate(lis):
            amounts.append(amount-last)
            last = amount

    for index,fAddress in enumerate(fakeAddressList):
        if cheatingAddress != fAddress:
            sAddress = supportAddressList[random.randint(0,len(supportAddressList)-1)]
            _timestamp = random.randint(timestamps[0],timestamps[1]-3)
            transactions.append(Transaction(cheatingAddress,fAddress,amounts[index],_timestamp))
            _timestamp = random.randint(_timestamp,timestamps[1]-2)
            transactions.append(Transaction(fAddress,sAddress,amounts[index],_timestamp))
            _timestamp = random.randint(_timestamp,timestamps[1]-1)
            transactions.append(Transaction(sAddress,fAddress,amounts[index],_timestamp))
            _timestamp = random.randint(_timestamp,timestamps[1])
            transactions.append(Transaction(fAddress,cheatingAddress,amounts[index],_timestamp))
    return sorted(transactions,key = (lambda x:x.timestamp))

def generateFakeAddress(num):
    """generate fake address

    num: needed amount of fake addresses.
    """
    chars = '0123456789abcdef'
    fakeAddressList=[]
    for i in xrange(num):
       address = [chars[random.randint(0,15)] for j in range(40)] 
       fakeAddressList.append('0x'+''.join(address))
    return fakeAddressList

def readAddresses(fileName):
    """read addresses from file
    """
    addresses = []
    with open(fileName,'r') as fo:
        for line in fo:
            line = line.strip('\n')
            addresses.append(line)
    return addresses

def readTransactions(fileName):
    transactions = []
    address = set()
    timestamp_min = -1
    timestamp_max = -1
    with open(fileName,'r') as fo:
        for line in fo:
            line = line.strip('\n')
            segments = line.split(',')
            timestamp = int(segments[3])
            if len(segments) == 5:
                transactions.append(Transaction(segments[1],segments[2],float(segments[4]),timestamp))
            if timestamp_min==-1 or timestamp_min>timestamp:
                timestamp_min = timestamp
            if timestamp_max == -1 or timestamp_max<timestamp:
                timestamp_max = timestamp
            address.add(segments[1])
            address.add(segments[2])
    return transactions,list(address),timestamp_min,timestamp_max

def writeTransactions(transactions,fileName):
    with open(fileName,'w') as fo:
        index = 0
        lastTimestamp = -1
        for transaction in transactions:
            if lastTimestamp!=transaction.timestamp:
                index = 0
            else:
                index +=1
            if lastTimestamp != -1:
                fo.write('\n')
            fo.write(str(index)+','+transaction.toString())
            lastTimestamp = transaction.timestamp

if __name__=='__main__':
    transactions,address,timestamp_min,timestamp_max = readTransactions('ethereum_user_edges.txt')
    print len(transactions)
    #newTransactions = generateNoise(transactions,address,[timestamp_min,timestamp_max],10,10)

    fakeAddressList = generateFakeAddress(2)
    #supportAddressList = readAddress('importantAddress.txt') 
    newTransactions = generateFake(transactions,'0x893ebb8f0e51deb85678453b0fadfd87254a5243', \
        ['0x32be343b94f860124dc4fee278fdcbd38c102d88','0x2910543af39aba0cd09dbb2d50200b3e800a63d2'],\
        fakeAddressList,100,[timestamp_min,timestamp_max],method='random')

    print len(newTransactions)
    writeTransactions(newTransactions,'newdata.txt')